module SYNTAX-CONVERSIONS
    imports CORE-SORTS
    imports CORE-FUNCTIONS
    imports CORE-CLASSES    //for cast
    imports CORE-EXEC

/*@ Defining the syntax for key portions of the semantics, and converting AST terms back int otheir syntactiv form.
*/

/*@ \subsection{Method invocation}*/

/*
General structure:

'Invoke(
  'Method(
    'MethodName(
      QualifierExp:Expression,,
      Name:Id
    )
  ),,
  [Args] - argument expressions
)
*/

/* 'Method(Qual:K,, \_:K,, Name:Id)
    'Method('MethodName(Qual:K,, Name:Id))
*/
rule 'Invoke('Method( 'MethodName( Qual:K,, Name:Id ) ),, ArgList:KListWrap) => Qual.Name(toExps(ArgList)) [structural]

//totest model check - expressions should be evaluated from left to right. A test for this
//exists, but is unable to expose the problem. This rule have to be made "transition"
//somehow.
//totest - if qualifier evaluates to null, NullPointerException should be thrown after
//the evaluation of the arguments
/*@ Method invocation expression
*/


/*@ \subsection{Local variable declaration}*/
syntax LocalVarDecStmt ::= Type Id ";"
rule 'LocalVarDec(_:K,, T:Type,,['VarDec(X:Id)]) => T X;  [structural]

/*@ \subsection{Cast}*/
//this might be confused with castprim or castref
syntax Exp ::= "(" "(" Type ")" K ")" [klabel('CastImpl)]
rule ((T:Type) K:K) => cast(T, K)
rule ( T:RefType ) E:Exp => cast(T,E)
rule ( T:PrimType ) E:Exp => cast(T,E)

/*@ \subsection{Identifier (name) expression}*/

//Naked identifier on top of computation
syntax Exp ::= Id
rule X:Id => 'ExprName(X)
rule lvalue(X:Id) => lvalue('ExprName(X))

/* 'NewInstance( _:K,, Class:ClassType,, [Args],, 'None(.KList) )

    Although we could have just 'QNewInstance at runtime, having runtime semantics for 'NewInstance is preferred
    because we have a lot of 'Throw('NewInstance()) through our runtime semantics.
*/
rule 'NewInstance( 'None(.KList),, Class:ClassType,, [ Args:KList ],, 'None(.KList) )
     => new Class( toExps([Args]) )


// 'QNewInstance( Qual,, _:K,, Class,, _:K,, [Args],, 'None(.KList) )
rule 'QNewInstance( Qual:Exp,, _:K,, ClassOrName:ClassOrName,, _:K,, [Args:KList],, _:K )
     => Qual . new ClassOrName( toExps([Args]) )


/*@Unpack 'NewInstance back into 'QNewInstance.
  The difference between desugaring and unpacking is that unpacking is an artificial procedure required to separate
  elaboration from execution. In the elaboration phase there is a opposite packing rule tht creates this construct.
*/
rule [NewInstance-to-QNewInstance-unpack]:
    new Class:ClassType(ArgExps:Exps)
    => (noValue):>Exp . new Class:ClassType(ArgExps:Exps)

/*@ \subsection{Syntactic lists - Exps, TypedVals, ClassTypes}*/

/*@
  A list of expressions, usually a list of arguments of a method or constructor.
*/

syntax KItem ::= toExps( KListWrap )        [function]
               | toExps( KListWrap , Exps ) [function]

rule toExps([Args:KList]) => toExps([Args], .Exps)
rule toExps([Arg:Exp,, Args:KList], Es) => toExps([Args], addElementToExpsEnd(Es, Arg))
rule toExps([.KList], Es) => Es

//this function is needed because we can no longer match elements in the end of KList
syntax Exps ::= addElementToExpsEnd (Exps, Exp) [function]
rule addElementToExpsEnd(.Exps, P:Exp) => P,.Exps
rule addElementToExpsEnd((Hd:Exp, Tl:Exps), P:Exp) => Hd,addElementToExpsEnd(Tl,P)

syntax KItem ::= toKListWrap( Exps )              [function]
               | toKListWrap( KListWrap , Exps )  [function]

rule toKListWrap(Args:Exps) => toKListWrap([.KList], Args)
rule toKListWrap([Args:KList], (Arg:Exp, Es:Exps)) => toKListWrap([Args,, Arg], (Es))
rule toKListWrap([Args:KList], .Exps) => [Args]

syntax Exps ::= TypedVals

syntax KResult ::= ClassTypes
syntax ClassTypes ::= List{ClassType, ","}

endmodule
