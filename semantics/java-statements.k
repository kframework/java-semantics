module JAVA-STATEMENTS
    imports JAVA-CORE

//@ \section{Program stack}

//ListItem content as a stack layer
syntax K ::=
    "("
      StackLayerType "," //StackLT - type of stack layer, see StackLayerType
      K ","   //CatchParam, X - layer param
      K ","   //CatchStm, FinallyStm, ... - layer statement
      K ","   //K - rest of computation
      Map "," //Env
      Bag     //C - rest of control
    ")"

//stack layer types
syntax StackLayerType ::=
      "return"   //generated by method invocations, consumed by return
    | "catch"    //generated by TryCatch, consumed by throw
    | "finally"  //generated by TryFinally, consumed by all flow interruptions
    | "loop"     //generated by While / DoWhile / For,
                 //  consumed by break, continue
    | "forBody"  //generated by for, consumed by continue
    | "label"    //generated by Labeled, consumed by break with label.
                 //  Also used by loop rules
                 //  to prepare context for continue with label.
    | "switch"   //generated by switch, consumed by break

syntax K ::= "popx" //discard the top stack layer

rule [popx]:
    <k> popx => . ...</k>
    <stack> _:ListItem => . ...</stack>

//@ \section{Blocks} JLS $14.2

rule [Block]:
    <k> 'Block(S) => S ~> env(Env) ...</k>
    <env> Env </env>
        [structural]

rule [ListOfStatements]:
    'ListWrap(S1,,Ss:List{K}) => S1 ~> 'ListWrap(Ss)
        [structural]

rule [DiscardEmptyList]:
    <k> 'ListWrap(.List{K}) => . ...</k>
        [structural]

//@ \texttt{env}

//restore the env cell content from env(...) statement argument
syntax K ::= "env" "(" Map ")"

rule [env]:
    <k> env(Env) => . ...</k>
    <env> _ => Env </env>
        [structural]

rule [envDiscard]:
    (env(_) => .) ~> env(_)
        [structural]

//@ \section{Local Variable Declaration Statements} JLS $14.4
//@ Not only local but fields also

//local var decs and field decs are reduced to a single case
rule [LocalVarDecStmRed]:
    'LocalVarDecStm('LocalVarDec(_,, TypeK:K,, 'ListWrap(Ks)))
    => 'LocalVarDec(TypeK,, 'ListWrap(Ks))
        [structural]

rule [FieldDecToLocalVarDec]:
    'FieldDec(_,, TypeK:K,, 'ListWrap(Ks))
    => 'LocalVarDec(TypeK,, 'ListWrap(Ks))
        [structural]

rule [VarListDecDesugar]:
    'LocalVarDec(TypeK,, 'ListWrap(Var1:K,, Var2:K,, VarDecs:List{K}))
    => 'LocalVarDec(TypeK,, 'ListWrap(Var1))
        ~> 'LocalVarDec(TypeK,, 'ListWrap(Var2,, VarDecs))
      [structural]

rule [VarDecWithInitDesugar]:
    'LocalVarDec(TypeK,, 'ListWrap('VarDec(X1:Id,,K3:K)))
    => 'LocalVarDec(TypeK,, 'ListWrap('VarDec(X1:Id)))
        ~> 'ExprStm('Assign('ExprName(X1),, K3))
      [structural]

/*In Java current version of semantics only int and boolean primitive
types are supported*/

context 'LocalVarDec(HOLE,,_)

rule [LocalVarDec]:
    <k> 'LocalVarDec(T:Type,,'ListWrap('VarDec(X:Id))) => . ...</k>
    <env> Env:Map => Env[L:Int/X] </env>
    <store>... . => L |-> undefined :: T ...</store>
    <nextLoc> L => L +Int 1 </nextLoc>

//@ \section{Empty statement} JLS $14.6

rule [Empty]:
    'Empty(_) => .

//@ \section{Labeled statements} JLS $14.7

rule [Labeled]:
    <k> ('Labeled(X,,S) => S ~> popx) ~> K </k>
    <control>
      <stack> . => ListItem((label, X, S, K, Env, C)) ...</stack>
      C:Bag
    </control>
    <env> Env </env>

//@ \section{Expression statements} JLS $14.8

context 'ExprStm(HOLE)

rule [ExprStm]:
    'ExprStm(_:TypedVal) => .

//@ \section{If statement}

context 'If(HOLE,,_,,_)

rule [IfTrue]:
    'If(true::bool,, S,, _) => S

rule [IfFalse]:
    'If(false::bool,, _,, S) => S

rule [IfThenDesugar]:
    'If(E:K,,S1:K) => 'If(E:K,,S1:K,,'Block('ListWrap(.List{K})))

//@ \section{Assert statement}

context 'AssertStm(HOLE,,_:List{K})

rule [AssertStmTrueDiscard]:
    'AssertStm(true::bool,, _:List{K}) => .

rule [AssertStmOneArg]:
    'AssertStm(false::bool) => 'Throw('NewInstance(
      'None(.List{K}),,
      'ClassOrInterfaceType( 'TypeName( String2Id("AssertionError") ),, 'None(.List{K}) ),,
      'ListWrap( null :: nullType ),,
      'None(.List{K})
    ))

context 'AssertStm(false::bool,, HOLE)

rule [AssertStmTwoArgs]:
    'AssertStm(false::bool,, TV:TypedVal) => 'Throw('NewInstance(
      'None(.List{K}),,
      'ClassOrInterfaceType( 'TypeName( String2Id("AssertionError") ),, 'None(.List{K}) ),,
      'ListWrap( toString(TV) ),,
      'None(.List{K})
    ))

//@ \section{Switch statement}

syntax K ::= "switchImpl"
                TypedVal "," // TV - switch param
                List{K} ","  // switch body - list of 'SwitchGroup labels
                K            // DefaultStm - default block, if any

context 'Switch(HOLE,,_)

rule [Switch]:
    <k>
      ( 'Switch(TV,, 'SwitchBlock('ListWrap(Ks),, TrailingLabels:K))
        => switchImpl TV, (Ks,, 'SwitchGroup(TrailingLabels,, .K)), .K )
      ~> K
    </k>
    <control>
      <stack> . => ListItem((switch, .K, .K, K, Env, C)) ...</stack>
      C:Bag
    </control>
    <env> Env </env>

context switchImpl _,
          ( 'SwitchGroup('ListWrap('Case(HOLE),,_:List{K}),,_),, _:List{K} ), _

//the type associated to V and V2 is not important for match, only the value.
//JLS3 $14.11, page 377: Every case constant expression associated with
//a switch statement must be assignable (§5.2) to the type of the switch Expression.

rule [SwitchCaseNotMatch]:
    switchImpl V:RawVal :: _, ( 'SwitchGroup('ListWrap(
        ( 'Case(V2:RawVal :: _) => .List{K} ),,
        _:List{K} ),,_),, _), _
when
    V =/=K V2

/*@Once case of first switch group matches, the whole switch is replaced
by it's block. The execution rules for switch will discard switch-related
constructs and will execute the statements. */

rule [SwitchCaseMatch]:
    ( switchImpl V :: _, ('SwitchGroup('ListWrap('Case(V :: _),,_:List{K}),,S),,Ks), _ )
    => 'ListWrap(S,,Ks)

rule [SwitchDefaultSave]:
    switchImpl TV, (
      'SwitchGroup('ListWrap(
          ( 'Default(_) => .List{K} ),,
          _:List{K}),, S),, Ks
    ),
    ( _:K => 'ListWrap(S,, Ks) )

rule [SwitchGroupDiscard]:
    switchImpl TV, (
        ( 'SwitchGroup('ListWrap( .List{K} ),,_) => .List{K} ),,
    _), _

rule [SwitchDefaultExec]:
    switchImpl _, .List{K}, DefaultStm:K => DefaultStm

rule [SwitchGroupExec]:
    'SwitchGroup(_:K,, S) => S

//@ \section{While statement} and loop infrastructure.

rule [While]:
    <k> ( 'While(E:K,,S:K)
          => saveLoop(loopImpl(E, S, .K),K) ~> loopImpl(E, S, .K) ~> popx )
        ~> K
    </k>
        [structural]

syntax K ::= "loopImpl" "("
                K ","  // E - test expression
                K ","  // S - loop body
                K      // UpdClause - present for For, empty for other loops.
             ")"

rule [loopImpl]:
    <k> loopImpl(E, S, UpdClause)
        => 'If(E,, 'Block(S ~> UpdClause ~> loopImpl(E, S, UpdClause)),, .K)
      ...
    </k>
        [structural]

syntax K ::= "saveLoop" "("
                K "," // LoopStm - the whole while / do / for statement
                K     // K - rest of computation
             ")"

rule [saveLoop]:
    <k> (saveLoop(LoopStm:K, K) => .) ...</k>
    <control>
      <stack>
        ( . => ListItem((loop, getLoopLabel(ParentLayer), LoopStm, K, Env, C)) )
        ListItem(ParentLayer:K)
        ...
      </stack>
      C:Bag
    </control>
    <env> Env </env>

/*@ \texttt{Label propagation} through stack layers, used by
continue statement with label.*/

declare getLoopLabel : K -> K

define getLoopLabel((label, X, S, _,_,_:Bag)) => X
when
             getKLabel(S) ==KLabel 'While
      orBool getKLabel(S) ==KLabel 'DoWhile
      orBool getKLabel(S) ==KLabel 'For

define getLoopLabel((StackLT, _, S, _,_,_:Bag)) => .K
when
    StackLT =/=K label
    orBool notBool (
             getKLabel(S) ==KLabel 'While
      orBool getKLabel(S) ==KLabel 'DoWhile
      orBool getKLabel(S) ==KLabel 'For
    )

//@ \section{Do statement}
rule
    <k> ( 'DoWhile(S,,E)
          => saveLoop(loopImpl(E, S, .K), K) ~> S ~> loopImpl(E, S, .K) ~> popx
        )
        ~> K
    </k>
        [structural]

//@ \section{For statement}

//wrapper of certain clauses of for statement
syntax K ::= "stm" "(" K ")"

rule [stmDiscard]:
    stm('ListWrap(.List{K})) => .
        [structural]

rule [stmList]:
    stm('ListWrap(E:K,, Es:List{K})) => 'ExprStm(E) ~> stm('ListWrap(Es))
        [structural]

rule [stmLocalVarDec]:
    <k> stm('LocalVarDec(Ks)) => 'LocalVarDecStm('LocalVarDec(Ks)) ...</k>
        [structural]

rule [ForFirstArgV1Red]:
    'For((
      'ListWrap(InitExps:List{K}) => stm('ListWrap(InitExps))
    ),,_:List{K})
        [structural]

rule [ForFirstArgV2Red]:
    'For((
      'LocalVarDec(Ks:List{K}) => stm('LocalVarDec(Ks))
    ),,_:List{K})
        [structural]

rule [ForSecondArgRed]:
    'For(_:K,,(
      'None(.List{K}) => 'Some(true::bool)
    ),,_:List{K})
        [structural]

rule [ForThirdArgRed]:
    'For(_:K,,_:K,,(
      'ListWrap(UpdExps:List{K}) => stm('ListWrap(UpdExps))
    ),,_:K)
        [structural]

//this form of resulting while is required for compatibility with continue statement
rule [For]:
    <k> ( 'For(stm(InitClause:K),, 'Some(TestExp:K),, stm(UpdClause:K),, S:K)
          => saveLoop(loopImpl(TestExp, S, stm(UpdClause)), K) ~> 'Block(stm(InitClause)
              ~> saveForBody ~> loopImpl(TestExp, S, stm(UpdClause))) ~> popx
        )
        ~> K
    </k>
        [structural]

syntax K ::= "saveForBody"

rule [saveForBody]:
    <k> (saveForBody => .) ~> loopImpl(E, S, UpdClause) ~> (. => popx) ~> K </k>
    <control>
      <stack>
        ( . =>  ListItem( (forBody, getForBodyLabel(ParentLayer),
                         loopImpl(E, S, UpdClause), K, Env, C) ) )
        ListItem(ParentLayer)
        ...
      </stack>
      C:Bag
    </control>
    <env> Env </env>

declare getForBodyLabel : K -> K

//the parent layer of forBody is always loop
define getForBodyLabel((loop, K, _,_,_,_:Bag)) => K

//@ \section{Break statement}

rule [Break]:
    <k> 'Break('None(_)) ~> _:K => K </k>
    <control>
      <stack> ListItem((StackLT, _, _, K, Env, C)) => . ...</stack>
      (_ => C)
    </control>
    <env> _ => Env </env>
when
           StackLT ==K loop
    orBool StackLT ==K switch

rule [BreakPassThrough]:
    <k> 'Break('None(_)) ...</k>
    <stack> ListItem((StackLT:StackLayerType,_,_,_,_,_:Bag)) => . ...</stack>
when
            StackLT =/=K loop
    andBool StackLT =/=K switch
    andBool StackLT =/=K finally

//break with label
rule [BreakLabel]:
    <k> 'Break('Some(X)) ~> _:K => K </k>
    <control>
      <stack> ListItem((label, X, _, K, Env, C)) => . ...</stack>
      (_ => C)
    </control>
    <env> _ => Env </env>

rule [BreakLabelPassThrough]:
    <k> 'Break('Some(X)) ...</k>
    <stack> ListItem((StackLT, StackArg2:K, _,_,_,_:Bag)) => . ...</stack>
when
    (
              StackLT =/=K label
      andBool StackLT =/=K finally
    )
    orBool (
              StackLT ==K label
      andBool X =/=K StackArg2
    )

//works for both break with and without label
rule [BreakAnyInTryFinally]:
    <k> (. => FinallyS) ~> 'Break(_) ...</k>
    <control>
      <stack> ListItem((finally,_,FinallyS,_,Env,C)) => . ...</stack>
      (_ => C)
    </control>
    <env> _ => Env </env>

//@ \section{Continue statement}

rule [Continue]:
    <k> 'Continue('None(_)) ~> _:K => UpdClause ~> loopImpl(E, S, UpdClause) ~> popx ~> K </k>
    <control>
      <stack>
        ListItem((StackLT, _, loopImpl(E, S, UpdClause), K, Env, C))
        ...
      </stack>
      (_ => C)
    </control>
    <env> _ => Env </env>
when
    StackLT ==K loop orBool StackLT ==K forBody

rule [ContinuePassThrough]:
    <k> 'Continue('None(_)) ...</k>
    <stack>
      ListItem((StackLT,_,_,_,_,_:Bag)) => .
      ...
    </stack>
when
            StackLT =/=K loop
    andBool StackLT =/=K forBody
    andBool StackLT =/=K finally

rule [ContinueLabel]:
    <k> 'Continue('Some(X)) ~> _:K => UpdClause ~> loopImpl(E, S, UpdClause) ~> popx ~> K </k>
    <control>
      <stack>
        ListItem((StackLT, X, loopImpl(E, S, UpdClause), K, Env, C))
        ...
      </stack>
      (_ => C)
    </control>
    <env> _ => Env </env>
when
           StackLT ==K loop
    orBool StackLT ==K forBody

rule [ContinueLabelPassThrough]:
    <k> 'Continue('Some(X)) ...</k>
    <stack>
      ListItem((StackLT, StackArg2:K, _,_,_,_:Bag)) => .
      ...
    </stack>
when
    (
              StackLT =/=K loop
      andBool StackLT =/=K forBody
      andBool StackLT =/=K finally
    )
    orBool (
      (
               StackLT ==K loop
        orBool StackLT ==K forBody
      )
      andBool (
        X =/=K StackArg2
      )
    )

//works for both break with and without label
rule [ContinueAnyInTryFinally]:
    <k> (. => FinallyS) ~> 'Continue(_) ...</k>
    <control>
      <stack>
        ListItem((finally,_,FinallyS,_,Env,C)) => .
        ...
      </stack>
      (_ => C)
    </control>
    <env> _ => Env </env>

/*@\section{Return} At method return, we have to check that the type
of the returned
value is a subtype of the expected return type.  Moreover, if that is
the case, then we also upcast the returned value to one of the
expected type. */

context 'Return('Some(HOLE))

rule [ReturnNothingDesugar]:
    'Return('None(.List{K}) => 'Some(nothing :: void))
        [structural]

rule [Return]:
    <k>
      'Return('Some(V:RawVal :: T2:Type)) ~> _
      => subtype T2, T1 ~> true? ~> V::T1 ~> K:K
    </k>
   <control>
     <stack> ListItem((return,_,_,K,Env,C)) => . ...</stack>
     ( <return> T1:Type </return> _ => C )
   </control>
   <env> _ => Env </env>

rule [ReturnInTryFinally]:
    <k> (. => FinallyS) ~> 'Return('Some(TV)) ...</k>
    <control>
      <stack> ListItem((finally,_,FinallyS,_,Env,C)) => . ...</stack>
      (_ => C)
    </control>
    <env> _ => Env </env>

rule [ReturnPassThrough]:
    <k> 'Return('Some(TV)) ...</k>
    <stack> ListItem((StackLT,_,_,_,_,_:Bag)) => . ...</stack>
when
            StackLT =/=K return
    andBool StackLT =/=K finally

/*@ \section{Throw statement}
Exceptions are propagated now until a catch that can bind them is
encountered. */

context 'Throw(HOLE)

rule [Throw]:
    <k>
      'Throw(TV) ~> _:K
      =>  'If(
            (subtype typeOf(TV), T),,
            'Block('ListWrap('LocalVarDecStm('LocalVarDec(
                'ListWrap(.List{K}),, T,, 'ListWrap('VarDec(X,, TV)))),,
                CatchS)),,
            'Throw(TV)
          )
          ~> K
    </k>
    <control>
      <stack>
        ListItem((catch, 'Param(_:K,, T,, X:Id), CatchS, K, Env, C)) => .
        ...
      </stack>
      (_ => C)
    </control>
    <env> _ => Env </env>

rule [ThrowInTryFinally]:
    <k> (. => FinallyS) ~> 'Throw(_:TypedVal) ...</k>
    <control>
      <stack> ListItem((finally,_,FinallyS,_,Env,C)) => . ...</stack>
      (_ => C)
    </control>
    <env> _ => Env </env>

rule [ThrowPassThrough]:
    <k> 'Throw(_:TypedVal) ...</k>
    <stack> ListItem((StackLT,_,_,_,_,_:Bag)) => . ...</stack>
when
            StackLT =/=K catch
    andBool StackLT =/=K finally

rule [ThrowCausesThreadTermination]:
    <k>
      'Throw(TV) ~> _:K
      => 'ExprStm('Invoke(rtSystemOutPrintln,, 'ListWrap(
          'Plus("Thread terminated with exception: "::rtString,, TV))))
    </k>
    <stack> .List </stack>

//@ \section{Try statement}

rule [TryCatchFinallyDesugar]:
    'Try(TryS:K,, 'ListWrap( K,,Ks),,FinallyS:K)
    => 'Try('Try(TryS,,'ListWrap( K,,Ks)),,'ListWrap(.List{K}),,FinallyS)
        [structural]

rule [TryCatchCatchDesugar]:
    'Try(TryS,, 'ListWrap(Ks,, K1:K,, K2:K))
    => 'Try('Try(TryS,, 'ListWrap( Ks,,K1)),, 'ListWrap(K2))
        [structural]

//@ \subsection{Execution of try–catch} JLS 14.20.1

//eval the type of catch argument
context 'Try(_:K,,'ListWrap('Catch('Param(_:K,, HOLE,, _),, _)))

rule [TryCatch]:
    <k>
      ( 'Try(TryS:K,, 'ListWrap('Catch(CatchParam:K,, CatchS:K)))
        => TryS ~> popx )
      ~> K
    </k>
    <control>
      <stack> . => ListItem((catch, CatchParam, CatchS, K, Env, C)) ...</stack>
      C:Bag
    </control>
    <env> Env </env>

//@ \subsection{Execution of try-finally} JLS 14.20.2

rule [TryFinally]:
    <k>
      ( 'Try(TryS:K ,,'ListWrap(.List{K}),,FinallyS:K)
        => TryS ~> popx ~> FinallyS )
      ~> K
    </k>
    <control>
      <stack> . => ListItem((finally, .K, FinallyS, .K, Env, C)) ...</stack>
      C:Bag
    </control>
    <env> Env </env>

//@ \section{Auxiliary operations}

rule [ThreadTermination]:
    ( <thread>
        ...
        <k>.K</k>
        <holds> H:Map </holds>
        ...
      </thread>
    => .)
    <busy> Busy:Set => Busy -Set keys(H) </busy>
    <dissolveEmptyK> true </dissolveEmptyK>

end module
