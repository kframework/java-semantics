module JAVA-STATEMENTS
    imports JAVA-CORE

//@ \section{Initiation of execution}

rule [StartExecutionPhase]:
    <k> . =>
      //k-ast for new <MainClass>().main(new String[0]);
      'ExprStm(
        'Invoke(
          'MethodName('TypeName(String2Id(MainClassS)),, String2Id("main")),,
          'ListWrap('NewArray(
              rtString,,
              'ListWrap('Dim(0 :: int)),,
              'ListWrap(.List{K})))
        )
      )
    </k>
    <env> . </env>
    <mainClass> ListItem(MainClassS:String) </mainClass>
    <computationPhase> ProcessClassesPhase => ExecutionPhase </computationPhase>

//@ \section{Program stack}

//ListItem content as a stack layer
syntax K ::=
    "("
      StackLayerType "," //StackLT - type of stack layer, see StackLayerType
      K ","   //CatchParam, X - layer param
      K ","   //CatchStm, FinallyStm, ... - layer statement
      K ","   //K - rest of computation
      Map "," //Env
      Bag     //C - rest of control
    ")"

//stack layer types
syntax StackLayerType ::=
      "return"   //generated by method invocations, consumed by return
    | "catch"    //generated by TryCatch, consumed by throw
    | "finally"  //generated by TryFinally, consumed by all flow interruptions
    | "loop"     //generated by While / DoWhile / For,
                 //  consumed by break, continue
    | "forBody"  //generated by for, consumed by continue
    | "label"    //generated by Labeled, consumed by break with label.
                 //  Also used by loop rules
                 //  to prepare context for continue with label.
    | "switch"   //generated by switch, consumed by break

//bug in K? we cannot use the constructions below, they will give some errors related to k-prelude.
//syntax StackConsumerLabel ::= 'Return | 'Throw | 'Break | 'Continue
//syntax KLabel ::= StackConsumerLabel

syntax K ::= "isStackConsumer" "(" KLabel ")" [function]
rule isStackConsumer (KL:KLabel) =>
           (KL ==KLabel 'Return)
    orBool (KL ==KLabel 'Throw)
    orBool (KL ==KLabel 'Break)
    orBool (KL ==KLabel 'Continue) [anywhere]

syntax K ::= "interactsWithStack" "(" K   // S - the stack consumer statement, see above
                              "," StackLayerType
                              "," K       // XK - second argument in stack layer after StackLayerType
                              ")" //-> Bool  true if statement interacts with the layer,
                                          // false if layer if layer is simply deleted

rule interactsWithStack('Return(_), StackLT:StackLayerType, _) =>
           (StackLT ==K return)
    orBool (StackLT ==K finally) [anywhere]

rule interactsWithStack('Throw(_), StackLT:StackLayerType, _) =>
           (StackLT ==K catch)
    orBool (StackLT ==K finally) [anywhere]

rule interactsWithStack('Break('None(_)), StackLT:StackLayerType, _) =>
           (StackLT ==K loop)
    orBool (StackLT ==K switch)
    orBool (StackLT ==K finally) [anywhere]

rule interactsWithStack('Break('Some(X:Id)), StackLT:StackLayerType, StackArg2:K) =>
         ( (StackLT ==K label)   andBool (X ==K StackArg2))
    orBool (StackLT ==K finally) [anywhere]

rule interactsWithStack('Continue('None(_)), StackLT:StackLayerType, _) =>
           (StackLT ==K loop)
    orBool (StackLT ==K forBody)
    orBool (StackLT ==K finally) [anywhere]

rule interactsWithStack('Continue('Some(X:Id)), StackLT:StackLayerType, StackArg2:K) =>
           ( (StackLT ==K loop)    andBool (X ==K StackArg2))
    orBool ( (StackLT ==K forBody) andBool (X ==K StackArg2))
    orBool   (StackLT ==K finally) [anywhere]

syntax K ::= "popx" //discard the top stack layer

rule [popx]:
    <k> popx => . ...</k>
    <stack> _:ListItem => . ...</stack>

//@ \section{Blocks} JLS $14.2

rule [Block]:
    <k> 'Block(S:K) => S ~> env(Env:Map) ...</k>
    <env> Env </env>
        [structural]

rule [ListOfStatements]:
    'ListWrap(S1:K,, Ss:List{K}) => S1 ~> 'ListWrap(Ss)
        [structural]

rule [DiscardEmptyList]:
    <k> 'ListWrap(.List{K}) => . ...</k>
        [structural]

//@ \texttt{env}

//restore the env cell content from env(...) statement argument
syntax K ::= "env" "(" Map ")"

rule [env]:
    <k> env(Env:Map) => . ...</k>
    <env> _ => Env </env>
        [structural]

rule [envDiscard]:
    (env(_) => .) ~> env(_)
        [structural]

//@ \section{Local Variable Declaration Statements} JLS $14.4
//@ Not only local but fields also

//local var decs and field decs are reduced to a single case
rule [LocalVarDecStmRed]:
    'LocalVarDecStm('LocalVarDec(_,, TypeK:K,, 'ListWrap(Ks:List{K})))
    => 'LocalVarDec(TypeK,, 'ListWrap(Ks))
        [structural]

rule [VarListDecDesugar]:
    'LocalVarDec(TypeK:K,, 'ListWrap(Var1:K,, Var2:K,, VarDecs:List{K}))
    => 'LocalVarDec(TypeK,, 'ListWrap(Var1))
        ~> 'LocalVarDec(TypeK,, 'ListWrap(Var2,, VarDecs))
      [structural]

rule [VarDecWithInitDesugar]:
    'LocalVarDec(TypeK:K,, 'ListWrap('VarDec(X1:Id,,InitExp:K)))
    => 'LocalVarDec(TypeK,, 'ListWrap('VarDec(X1:Id)))
        ~> 'ExprStm('Assign('ExprName(X1),, InitExp))
when
    getKLabel(InitExp) =/=KLabel 'ArrayInit
      [structural]

/*In Java current version of semantics only int and boolean primitive
types are supported*/

context 'LocalVarDec(HOLE,,_)

rule [LocalVarDec]:
    <k> 'LocalVarDec(T:Type,,'ListWrap('VarDec(X:Id))) => . ...</k>
    <env> Env:Map => Env[L:Int/X] </env>
    <store>... . => L |-> undefined :: T ...</store>
    <nextLoc> L => L +Int 1 </nextLoc>

//@ \section{Empty statement} JLS $14.6

rule [Empty]:
    'Empty(_) => .

//@ \section{Labeled statements} JLS $14.7

rule [Labeled]:
    <k> ('Labeled(X:Id,, S:K) => saveStackLayer(label,X,S,K) ~> S ~> popx) ~> K:K </k>

//@ \section{Expression statements} JLS $14.8

context 'ExprStm(HOLE)

rule [ExprStm]:
    'ExprStm(_:TypedVal) => .

//@ \section{If statement}

context 'If(HOLE,,_,,_)

rule [IfTrue]:
    'If(true::bool,, S:K,, _) => S

rule [IfFalse]:
    'If(false::bool,, _,, S:K) => S

rule [IfThenDesugar]:
    'If(E:K,,S1:K) => 'If(E:K,, S1:K,, .K)

//@ \section{Assert statement}

context 'AssertStm(HOLE,,_:List{K})

rule [AssertStmTrueDiscard]:
    'AssertStm(true::bool,, _:List{K}) => .

rule [AssertStmOneArg]:
    'AssertStm(false::bool) => 'Throw('NewInstance(
      'None(.List{K}),,
      'class_(String2Id("AssertionError")),,
      'ListWrap( null :: nullType ),,
      'None(.List{K})
    ))

context 'AssertStm(false::bool,, HOLE)

rule [AssertStmTwoArgs]:
    'AssertStm(false::bool,, TV:TypedVal) => 'Throw('NewInstance(
      'None(.List{K}),,
      'class_(String2Id("AssertionError")),,
      'ListWrap( toString(TV) ),,
      'None(.List{K})
    ))

//@ \section{Switch statement}

syntax K ::= "switchImpl"
                TypedVal "," // TV - switch param
                List{K} ","  // switch body - list of 'SwitchGroup labels
                K            // DefaultStm - default block, if any

context 'Switch(HOLE,,_)

rule [Switch]:
    <k>
      ( 'Switch(TV:TypedVal,, 'SwitchBlock('ListWrap(Ks:List{K}),, TrailingLabels:K))
        => saveStackLayer(switch, .K, .K, K)
      ~> switchImpl TV, (Ks,, 'SwitchGroup(TrailingLabels,, .K)), .K )
      ~> K:K
    </k>

context switchImpl _,
          ( 'SwitchGroup('ListWrap('Case(HOLE),,_:List{K}),,_),, _:List{K} ), _

//the type associated to V and V2 is not important for match, only the value.
//JLS3 $14.11, page 377: Every case constant expression associated with
//a switch statement must be assignable (§5.2) to the type of the switch Expression.

rule [SwitchCaseNotMatch]:
    switchImpl V:RawVal :: _, ( 'SwitchGroup('ListWrap(
        ( 'Case(V2:RawVal :: _) => .List{K} ),,
        _:List{K} ),,_),, _), _
when
    V =/=K V2

/*@Once case of first switch group matches, the whole switch is replaced
by it's block. The execution rules for switch will discard switch-related
constructs and will execute the statements. */

rule [SwitchCaseMatch]:
    ( switchImpl V:RawVal :: _, ('SwitchGroup('ListWrap('Case(V :: _),,_:List{K}),,S:K),,Ks:List{K}), _ )
    => 'ListWrap(S,,Ks)

rule [SwitchDefaultSave]:
    switchImpl TV:TypedVal, (
      'SwitchGroup('ListWrap(
          ( 'Default(_) => .List{K} ),,
          _:List{K}),, S:K),, Ks:List{K}
    ),
    ( _:K => 'ListWrap(S,, Ks) )

rule [SwitchGroupDiscard]:
    switchImpl TV:TypedVal, (
        ( 'SwitchGroup('ListWrap( .List{K} ),,_) => .List{K} ),,
    _), _

rule [SwitchDefaultExec]:
    switchImpl _, .List{K}, DefaultStm:K => DefaultStm

rule [SwitchGroupExec]:
    'SwitchGroup(_:K,, S:K) => S

//@ \section{While statement} and loop infrastructure.

rule [While]:
    <k> ( 'While(E:K,,S:K)
          => saveLoop(loopImpl(E, S, .K),K) ~> loopImpl(E, S, .K) ~> popx )
        ~> K:K
    </k>
        [structural]

syntax K ::= "loopImpl" "("
                K ","  // E - test expression
                K ","  // S - loop body
                K      // UpdClause - present for For, empty for other loops.
             ")"

rule [loopImpl]:
    <k> loopImpl(E:K, S:K, UpdClause:K)
        => 'If(E,, 'Block(S ~> UpdClause ~> loopImpl(E, S, UpdClause)),, .K)
      ...
    </k>
        [structural]

syntax K ::= "saveLoop" "("
                K "," // LoopStm - the whole while / do / for statement
                K     // K - rest of computation
             ")"

rule [saveLoop]:
    <k>
      saveLoop(LoopStm:K, K:K) => saveStackLayer(loop, getLoopLabel(ParentLayer), LoopStm, K)
      ...
    </k>
    <stack> ListItem(ParentLayer:K) ...</stack>

/*@ \texttt{Label propagation} through stack layers, used by
continue statement with label.*/

syntax K ::= "getLoopLabel" "(" K ")" [function]

rule getLoopLabel((StackLT:StackLayerType, K:K, KL:KLabel(_), _,_,_)) =>
    #if StackLT ==K label
        andBool (        (KL ==KLabel 'While)
                  orBool (KL ==KLabel 'DoWhile)
                  orBool (KL ==KLabel 'For) )

      #then K
      #else .K
    #fi [anywhere]

//@ \section{Do statement}
rule
    <k> ( 'DoWhile(S:K,,E:K)
          => saveLoop(loopImpl(E, S, .K), K) ~> S ~> loopImpl(E, S, .K) ~> popx
        )
        ~> K:K
    </k>
        [structural]

//@ \section{For statement}

//wrapper of certain clauses of for statement
syntax K ::= "stm" "(" K ")"

rule [stmDiscard]:
    stm('ListWrap(.List{K})) => .
        [structural]

rule [stmList]:
    stm('ListWrap(E:K,, Es:List{K})) => 'ExprStm(E) ~> stm('ListWrap(Es))
        [structural]

rule [stmLocalVarDec]:
    <k> stm('LocalVarDec(Ks:List{K})) => 'LocalVarDecStm('LocalVarDec(Ks)) ...</k>
        [structural]

rule [ForFirstArgV1Red]:
    'For((
      'ListWrap(InitExps:List{K}) => stm('ListWrap(InitExps))
    ),,_:List{K})
        [structural]

rule [ForFirstArgV2Red]:
    'For((
      'LocalVarDec(Ks:List{K}) => stm('LocalVarDec(Ks))
    ),,_:List{K})
        [structural]

rule [ForSecondArgRed]:
    'For(_:K,,(
      'None(.List{K}) => 'Some(true::bool)
    ),,_:List{K})
        [structural]

rule [ForThirdArgRed]:
    'For(_:K,,_:K,,(
      'ListWrap(UpdExps:List{K}) => stm('ListWrap(UpdExps))
    ),,_:K)
        [structural]

//this form of resulting while is required for compatibility with continue statement
rule [For]:
    <k> ( 'For(stm(InitClause:K),, 'Some(TestExp:K),, stm(UpdClause:K),, S:K)
          => saveLoop(loopImpl(TestExp, S, stm(UpdClause)), K) ~> 'Block(stm(InitClause)
              ~> saveForBody ~> loopImpl(TestExp, S, stm(UpdClause))) ~> popx
        )
        ~> K:K
    </k>
        [structural]

syntax K ::= "saveForBody"

rule [saveForBody]:
    <k>
      (saveForBody
          => saveStackLayer(forBody, getForBodyLabel(ParentLayer), loopImpl(E, S, UpdClause), K))
      ~> loopImpl(E:K, S:K, UpdClause:K) ~> (. => popx) ~> K:K
    </k>
    <stack> ListItem(ParentLayer:K) ...</stack>

syntax K ::= "getForBodyLabel" "(" K ")" [function]

//the parent layer of forBody is always loop
rule getForBodyLabel((loop, K:K, _,_,_,_:Bag)) => K [anywhere]

//@ \section{Break statement}

rule [Break]:
    <k> 'Break(Arg:K) ~> _:K => restoreControl(K,Env,C) </k>
    <stack> ListItem((StackLT:StackLayerType, XK:K, _, K:K, Env:Map, C:Bag)) => . ...</stack>
when
    interactsWithStack('Break(Arg), StackLT, XK)
    andBool (StackLT =/=K finally)

rule [StackConsumerStmPassThrough]:
    <k> KL:KLabel(Ks:List{K}) ...</k>
    <stack> ListItem((StackLT:StackLayerType, XK:K, _,_,_,_)) => . ...</stack>
when
    isStackConsumer(KL)
    andBool notBool interactsWithStack(KL(Ks), StackLT, XK)

//stack consumer stm - Return, Throw, Break or Continue reaches finally layer
rule [StackConsumerStmInTryFinally]:
    <k> (. => restoreControl(K,Env,C) ~> FinallyS) ~> KL:KLabel(_:List{K}) ...</k>
    <stack> ListItem((finally, _, FinallyS:K, K:K, Env:Map, C:Bag)) => . ...</stack>
when
  isStackConsumer(KL)

//@ \section{Continue statement}

rule [Continue]:
    <k>
      'Continue(Arg:K) ~> _:K
      => restoreControl(K,Env,C) ~> UpdClause ~> loopImpl(E, S, UpdClause) ~> popx
    </k>
    <stack>
      ListItem((StackLT:StackLayerType, XK:K, loopImpl(E:K, S:K, UpdClause:K),
                K:K, Env:Map, C:Bag))
      ...
    </stack>
when
    interactsWithStack('Continue(Arg), StackLT, XK)
    andBool (StackLT =/=K finally)

/*@\section{Return} At method return, we have to check that the type
of the returned
value is a subtype of the expected return type.  Moreover, if that is
the case, then we also upcast the returned value to one of the
expected type. */

context 'Return('Some(HOLE))

rule [ReturnNothingDesugar]:
    'Return('None(.List{K}) => 'Some(nothing :: void))
        [structural]

rule [Return]:
    <k>
      'Return('Some(V:RawVal :: T2:Type)) ~> _
      => restoreControl(K,Env,C) ~> subtype(T2, T1) ~> true? ~> V::T1
    </k>
    <stack> ListItem((return,_,_, K:K, Env:Map, C:Bag)) => . ...</stack>
    <return> T1:Type </return>

/*@ \section{Throw statement}
Exceptions are propagated now until a catch that can bind them is
encountered. */

context 'Throw(HOLE)

rule [Throw]:
    <k>
      (. => checkCatch(subtype(typeOf(TV:TypedVal), T))) ~> 'Throw(TV) ~> _:K
    </k>
    <stack>
      ListItem((catch, .K, 'ListWrap('Catch('Param(_:K,, T:Type,, X:Id),, _),,_), _, _, _))
      ...
    </stack>

syntax K ::= "checkCatch" "(" K ")"
context checkCatch(HOLE)

rule [ThrowCheckedTrue]:
    <k>
      checkCatch(true::bool) ~> 'Throw(TV:TypedVal) ~> _:K
      =>  restoreControl(K,Env,C)
          ~> 'Block('ListWrap('LocalVarDecStm('LocalVarDec(
                'ListWrap(.List{K}),, T,, 'ListWrap('VarDec(X,, TV)))),,
                CatchS))
    </k>
    <stack>
      ListItem((catch, .K, 'ListWrap('Catch(
          'Param(_:K,, T:Type,, X:Id),, CatchS:K),,_), K:K, Env:Map, C:Bag)) => .
      ...
    </stack>

syntax K ::= "restoreControl" "(" K "," Map "," Bag ")"
rule [restoreControl]:
    <k> ( restoreControl(K:K, Env:Map, C:Bag) => .) ~> _:K ~> (. => K) </k>
    <control>
      <stack> _:List </stack>
      (_ => C)
    </control>
    <env> _ => Env </env>

rule [ThrowCheckedFalse]:
    <k> (checkCatch(false::bool) => .) ~> 'Throw(TV:TypedVal) ~> _:K </k>
    <stack>
      ListItem((catch, .K,
        'ListWrap( ('Catch('Param(_:K,, T:Type,, X:Id),, CatchS:K) => .List{K}),, _),
      K:K, Env:Map, C:Bag))
      ...
    </stack>

rule [ThrowCatchEmptyDiscard]:
    <k> 'Throw(TV:TypedVal) ~> _:K </k>
    <stack> ListItem((catch, .K, 'ListWrap(.List{K}), K:K, Env:Map, C:Bag)) => . ...</stack>

rule [ThrowCausesThreadTermination]:
    <k>
      'Throw(TV:TypedVal) ~> _:K
      =>  'ExprStm('Invoke(
            'Method('MethodName(
              'AmbName('AmbName(String2Id("System")),, String2Id("out")),,
              String2Id("println")
            )),,
            'ListWrap(
                'Plus("Thread terminated with exception: "::rtString,, TV))
          ))
    </k>
    <stack> .List </stack>

//@ \section{Try statement}

rule [TryCatchFinallyDesugar]:
    'Try(TryS:K,, 'ListWrap(K:K,, Ks:List{K}),,FinallyS:K)
    => 'Try('Try(TryS,,'ListWrap(K,,Ks)),,'ListWrap(.List{K}),,FinallyS)
        [structural]

//@ \subsection{Execution of try–catch} JLS 14.20.1

//eval the type of catch argument
context 'Try(_:K,,'ListWrap('Catch('Param(_:K,, HOLE,, _),, _)))

rule [TryCatch]:
    <k>
      ( 'Try(TryS:K,, 'ListWrap(Ks:List{K}))
        => saveStackLayer(catch, .K, 'ListWrap(Ks), K) ~> TryS ~> popx )
      ~> K:K
    </k>

//@ \subsection{Execution of try-finally} JLS 14.20.2

rule [TryFinally]:
    <k>
      ( 'Try(TryS:K ,,'ListWrap(.List{K}),,FinallyS:K)
        => saveStackLayer(finally, .K, FinallyS, .K) ~> TryS ~> popx ~> FinallyS )
      ...
    </k>

//@ \section{Auxiliary operations}

rule [ThreadTermination]:
    ( <thread>
        ...
        <k>.K</k>
        <holds> H:Map </holds>
        ...
      </thread>
    => .)
    <busy> Busy:Set => Busy -Set keys(H) </busy>
    <computationPhase> ExecutionPhase </computationPhase>
    <dissolveEmptyK> true </dissolveEmptyK>

syntax K ::= "saveStackLayer" "("
                        StackLayerType ","  // The StackLayerType
                        K ","               // Id. for label - the label, for catch - catch var
                        K ","               // S - statement to be executed when this layer is consumed
                        K                   // K - the rest of computation
              ")"

rule [saveStackLayer]:
    <k> (saveStackLayer(StackLT:StackLayerType, IdK:K, S:K, K:K) => .) ~> _:K </k>
    <control>
      <stack> . => ListItem((StackLT, IdK, S, K, Env, C)) ...</stack>
      C:Bag
    </control>
    <env> Env:Map </env>

//Debug aid. Dissolves classes cell so that configuration is not overbloated, at the end
//of the execution.
rule [DissolveClasses]:
    (<classes> _:Bag </classes> => .)
    <threads> .Bag </threads>
    <computationPhase> ExecutionPhase </computationPhase>
    <dissolveClasses> true </dissolveClasses>

endmodule
