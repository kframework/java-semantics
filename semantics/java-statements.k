module JAVA-STATEMENTS
    imports JAVA-CORE
    imports JAVA-EXPRESSIONS

//@ \section{Program stack}

//ListItem content as a stack layer
syntax K ::= "("
                #Id "," //LayerType - type of stack layer, see stack layer types
                K ","   //CatchParam, X - layer param
                K ","   //CatchStm, FinallyStm, ... - layer statement
                K ","   //K - rest of computation
                Map "," //Env
                Bag     //C - rest of control
             ")"

//stack layer types
syntax #Id ::=  "return"   //generated by method invocations, consumed by return
              | "catch"    //generated by TryCatch, consumed by throw
              | "finally"  //generated by TryFinally, consumed by all flow interruptions
              | "loop"     //generated by While / DoWhile / For,
                           //  consumed by break, continue
              | "forBody"  //generated by for, consumed by continue
              | "label"    //generated by Labeled, consumed by break with label.
                           //  Also used by loop rules
                           //  to prepare context for continue with label.
              | "switch"   //generated by switch, consumed by break

syntax K ::= "popx" //discard the top stack layer

rule [popx]:
    <k> popx => . ...</k>
    <stack> _:ListItem => . ...</stack>

//@ \section{Blocks} JLS $14.2

rule [Block]:
    <k> 'Block(S) => S ~> env(Env) ...</k>
    <env> Env </env>
        [structural]

rule [ListOfStatements]:
    'ListWrap(S1,,Ss:List{K}) => S1 ~> 'ListWrap(Ss)
        [structural]

rule [DiscardEmptyList]:
    <k> 'ListWrap(.List{K}) => . ...</k>
        [structural]

//@ \texttt{env}

//restore the env cell content from env(...) statement argument
syntax K ::= "env" "(" Map ")"

rule [env]:
    <k> env(Env) => . ...</k>
    <env> _ => Env </env>
        [structural]

rule [envDiscard]:
    (env(_) => .) ~> env(_)
        [structural]

//@ \section{Local Variable Declaration Statements} JLS $14.4
//@ Not only local but fields also

//local var decs and field decs are reduced to a single case
rule [LocalVarDecStmRed]:
    'LocalVarDecStm('LocalVarDec(_,, TypeK:K,, 'ListWrap(Ks)))
    => 'LocalVarDec(TypeK,, 'ListWrap(Ks))
        [structural]

rule [FieldDecToLocalVarDec]:
    'FieldDec(_,, TypeK:K,, 'ListWrap(Ks))
    => 'LocalVarDec(TypeK,, 'ListWrap(Ks))
        [structural]

rule [VarListDecDesugar]:
    'LocalVarDec(TypeK,, 'ListWrap(Var1:K,, Var2:K,, VarDecs:List{K}))
    => 'LocalVarDec(TypeK,, 'ListWrap(Var1))
        ~> 'LocalVarDec(TypeK,, 'ListWrap(Var2,, VarDecs))
      [structural]

rule [VarDecWithInitDesugar]:
    'LocalVarDec(TypeK,, 'ListWrap('VarDec(X1:#Id,,K3:K)))
    => 'LocalVarDec(TypeK,, 'ListWrap('VarDec(X1:#Id)))
        ~> 'ExprStm('Assign('ExprName(X1),, K3))
      [structural]

/*In Java current version of semantics only int and boolean primitive
types are supported*/

context 'LocalVarDec(HOLE,,_)

rule [LocalVarDec]:
    <k> 'LocalVarDec(T:Type,,'ListWrap('VarDec(X:#Id))) => . ...</k>
    <env> Env:Map => Env[L:#Int/X] </env>
    <store>... . => L |-> undefined(T) ...</store>
    <nextLoc> L => L +Int 1 </nextLoc>

//@ \section{Empty statement} JLS $14.6

rule [Empty]:
    'Empty(_) => .

//@ \section{Labeled statements} JLS $14.7

rule [Labeled]:
    <k> ('Labeled(X,,S) => S ~> popx) ~> K </k>
    <control>
      <stack> . => ListItem((label, X, S, K, Env, C)) ...</stack>
      C:Bag
    </control>
    <env> Env </env>

//@ \section{Expression statements} JLS $14.8

context 'ExprStm(HOLE)

rule [ExprStm]:
    'ExprStm(V:Val) => .

//@ \section{If statement}

context 'If(HOLE,,_,,_)

rule [IfTrue]:
    'If(true,, S,, _) => S

rule [IfFalse]:
    'If(false,, _,, S) => S

rule [IfThenDesugar]:
    'If(E:K,,S1:K) => 'If(E:K,,S1:K,,'Block('ListWrap(.List{K})))

//@ \section{Switch statement}

syntax K ::= "switchImpl"
                Val ","      //V - switch param
                List{K} ","  //switch body - list of 'SwitchGroup labels
                K            //DefaultStm - default block, if any

context 'Switch(HOLE,,_)

rule [Switch]:
    <k>
      ( 'Switch(V,, 'SwitchBlock('ListWrap(Ks),, TrailingLabels:K))
        => switchImpl V, (Ks,, 'SwitchGroup(TrailingLabels,, .K)), .K )
      ~> K
    </k>
    <control>
      <stack> . => ListItem((switch, .K, .K, K, Env, C)) ...</stack>
      C:Bag
    </control>
    <env> Env </env>

context switchImpl _,
          ( 'SwitchGroup('ListWrap('Case(HOLE),,_:List{K}),,_),, _:List{K} ), _

rule [SwitchCaseNotMatch]:
    switchImpl V, ( 'SwitchGroup('ListWrap(
        ( 'Case(V2:Val) => .List{K} ),,
        _:List{K} ),,_),, _), _
when
    V =/=Bool V2

/*@Once case of first switch group matches, the whole switch is replaced
by it's block. The execution rules for switch will discard switch-related
constructs and will execute the statements. */

rule [SwitchCaseMatch]:
    ( switchImpl V, ('SwitchGroup('ListWrap('Case(V),,_:List{K}),,S),,Ks), _ )
    => 'ListWrap(S,,Ks)

rule [SwitchDefaultSave]:
    switchImpl V, (
      'SwitchGroup('ListWrap(
          ( 'Default(_) => .List{K} ),,
          _:List{K}),, S),, Ks
    ),
    ( _:K => 'ListWrap(S,, Ks) )

rule [SwitchGroupDiscard]:
    switchImpl V, (
        ( 'SwitchGroup('ListWrap( .List{K} ),,_) => .List{K} ),,
    _), _

rule [SwitchDefaultExec]:
    switchImpl _, .List{K}, DefaultStm:K => DefaultStm

rule [SwitchGroupExec]:
    'SwitchGroup(_:K,, S) => S

//@ \section{While statement} and loop infrastructure.

rule [While]:
    <k> ( 'While(E:K,,S:K)
          => saveLoop(loopImpl(E, S, .K),K) ~> loopImpl(E, S, .K) ~> popx )
        ~> K
    </k>
        [structural]

syntax K ::= "loopImpl" "("
                K ","  //E - test expression
                K ","  //S - loop body
                K      //UpdClause - present for For, empty for other loops.
             ")"

rule [loopImpl]:
    <k> loopImpl(E, S, UpdClause)
        => 'If(E,, 'Block(S ~> UpdClause ~> loopImpl(E, S, UpdClause)),, .K)
      ...
    </k>
        [structural]

syntax K ::= "saveLoop" "("
                K "," //LoopStm - the whole while / do / for statement
                K     //K - rest of computation
             ")"

rule [saveLoop]:
    <k> (saveLoop(LoopStm:K, K) => .) ...</k>
    <control>
      <stack>
        ( . => ListItem((loop, getLoopLabel(ParentLayer), LoopStm, K, Env, C)) )
        ListItem(ParentLayer:K)
        ...
      </stack>
      C:Bag
    </control>
    <env> Env </env>

/*@ \texttt{Label propagation} through stack layers, used by
continue statement with label.*/

declare getLoopLabel : K -> K

define getLoopLabel((label, X, S, _,_,_:Bag)) => X
when
             getKLabel(S) ==Bool 'While
      orBool getKLabel(S) ==Bool 'DoWhile
      orBool getKLabel(S) ==Bool 'For

define getLoopLabel((LayerType, _, S, _,_,_:Bag)) => .K
when
    LayerType =/=Bool label
    orBool notBool (
             getKLabel(S) ==Bool 'While
      orBool getKLabel(S) ==Bool 'DoWhile
      orBool getKLabel(S) ==Bool 'For
    )

//@ \section{Do statement}
rule
    <k> ( 'DoWhile(S,,E)
          => saveLoop(loopImpl(E, S, .K), K) ~> S ~> loopImpl(E, S, .K) ~> popx
        )
        ~> K
    </k>
        [structural]

//@ \section{For statement}

//wrapper of certain clauses of for statement
syntax K ::= "stm" "(" K ")"

rule [stmDiscard]:
    stm('ListWrap(.List{K})) => .
        [structural]

rule [stmList]:
    stm('ListWrap(E:K,, Es:List{K})) => 'ExprStm(E) ~> stm('ListWrap(Es))
        [structural]

rule [stmLocalVarDec]:
    <k> stm('LocalVarDec(Ks)) => 'LocalVarDecStm('LocalVarDec(Ks)) ...</k>
        [structural]

rule [ForFirstArgV1Red]:
    'For((
      'ListWrap(InitExps:List{K}) => stm('ListWrap(InitExps))
    ),,_:List{K})
        [structural]

rule [ForFirstArgV2Red]:
    'For((
      'LocalVarDec(Ks:List{K}) => stm('LocalVarDec(Ks))
    ),,_:List{K})
        [structural]

rule [ForSecondArgRed]:
    'For(_:K,,(
      'None(.List{K}) => 'Some(true)
    ),,_:List{K})
        [structural]

rule [ForThirdArgRed]:
    'For(_:K,,_:K,,(
      'ListWrap(UpdExps:List{K}) => stm('ListWrap(UpdExps))
    ),,_:K)
        [structural]

//this form of resulting while is required for compatibility with continue statement
rule [For]:
    <k> ( 'For(stm(InitClause:K),, 'Some(TestExp:K),, stm(UpdClause:K),, S:K)
          => saveLoop(loopImpl(TestExp, S, stm(UpdClause)), K) ~> 'Block(stm(InitClause)
              ~> saveForBody ~> loopImpl(TestExp, S, stm(UpdClause))) ~> popx
        )
        ~> K
    </k>
        [structural]

syntax K ::= "saveForBody"

rule [saveForBody]:
    <k> (saveForBody => .) ~> loopImpl(E, S, UpdClause) ~> (. => popx) ~> K </k>
    <control>
      <stack>
        ( . =>  ListItem( (forBody, getForBodyLabel(ParentLayer),
                         loopImpl(E, S, UpdClause), K, Env, C) ) )
        ListItem(ParentLayer:K)
        ...
      </stack>
      C:Bag
    </control>
    <env> Env </env>

declare getForBodyLabel : K -> K

//the parent layer of forBody is always loop
define getForBodyLabel((loop, K, _,_,_,_:Bag)) => K

//@ \section{Break statement}

rule [Break]:
    <k> 'Break('None(_)) ~> _:K => K </k>
    <control>
      <stack> ListItem((LayerType, _, _, K, Env, C)) => . ...</stack>
      (_ => C)
    </control>
    <env> _ => Env </env>
when
           LayerType ==Bool loop
    orBool LayerType ==Bool switch

rule [BreakPassThrough]:
    <k> 'Break('None(_)) ...</k>
    <stack> ListItem((LayerType:#Id,_,_,_,_,_:Bag)) => . ...</stack>
when
            LayerType =/=Bool loop
    andBool LayerType =/=Bool switch
    andBool LayerType =/=Bool finally

//break with label
rule [BreakLabel]:
    <k> 'Break('Some(X)) ~> _:K => K </k>
    <control>
      <stack> ListItem((label, X, _, K, Env, C)) => . ...</stack>
      (_ => C)
    </control>
    <env> _ => Env </env>

rule [BreakLabelPassThrough]:
    <k> 'Break('Some(X)) ...</k>
    <stack> ListItem((LayerType:#Id, StackArg2:K, _,_,_,_:Bag)) => . ...</stack>
when
    (
              LayerType =/=Bool label
      andBool LayerType =/=Bool finally
    )
    orBool (
              LayerType ==Bool label
      andBool X =/=Bool StackArg2
    )

//works for both break with and without label
rule [BreakAnyInTryFinally]:
    <k> (. => FinallyS) ~> 'Break(_) ...</k>
    <control>
      <stack> ListItem((finally,_,FinallyS,_,Env,C)) => . ...</stack>
      (_ => C)
    </control>
    <env> _ => Env </env>

//@ \section{Continue statement}

rule [Continue]:
    <k> 'Continue('None(_)) ~> _:K => UpdClause ~> loopImpl(E, S, UpdClause) ~> popx ~> K </k>
    <control>
      <stack>
        ListItem((LayerType, _, loopImpl(E, S, UpdClause), K, Env, C))
        ...
      </stack>
      (_ => C)
    </control>
    <env> _ => Env </env>
when
    LayerType ==Bool loop orBool LayerType ==Bool forBody

rule [ContinuePassThrough]:
    <k> 'Continue('None(_)) ...</k>
    <stack>
      ListItem((LayerType:#Id,_,_,_,_,_:Bag)) => .
      ...
    </stack>
when
            LayerType =/=Bool loop
    andBool LayerType =/=Bool forBody
    andBool LayerType =/=Bool finally

rule [ContinueLabel]:
    <k> 'Continue('Some(X)) ~> _:K => UpdClause ~> loopImpl(E, S, UpdClause) ~> popx ~> K </k>
    <control>
      <stack>
        ListItem((LayerType, X, loopImpl(E, S, UpdClause), K, Env, C))
        ...
      </stack>
      (_ => C)
    </control>
    <env> _ => Env </env>
when
           LayerType ==Bool loop
    orBool LayerType ==Bool forBody

rule [ContinueLabelPassThrough]:
    <k> 'Continue('Some(X)) ...</k>
    <stack>
      ListItem((LayerType:#Id, StackArg2:K, _,_,_,_:Bag)) => .
      ...
    </stack>
when
    (
              LayerType =/=Bool loop
      andBool LayerType =/=Bool forBody
      andBool LayerType =/=Bool finally
    )
    orBool (
      (
               LayerType ==Bool loop
        orBool LayerType ==Bool forBody
      )
      andBool (
        X =/=Bool StackArg2
      )
    )

//works for both break with and without label
rule [ContinueAnyInTryFinally]:
    <k> (. => FinallyS) ~> 'Continue(_) ...</k>
    <control>
      <stack>
        ListItem((finally,_,FinallyS,_,Env,C)) => .
        ...
      </stack>
      (_ => C)
    </control>
    <env> _ => Env </env>

/*@\section{Return} At method return, we have to check that the type
of the returned
value is a subtype of the expected return type.  Moreover, if that is
the case, then we also upcast the returned value to one of the
expected type. */

context 'Return('Some(HOLE))

rule [ReturnNothingDesugar]:
    'Return('None(.List{K}) => 'Some(nothing))
        [structural]

rule [Return]:
    <k>
      'Return('Some(V)) ~> _
      => subtype typeOf(V), T ~> true? ~> unsafeCast(V, T) ~> K:K
    </k>
   <control>
     <stack> ListItem((return,_,_,K,Env,C)) => . ...</stack>
     ( <return> T </return> _ => C )
   </control>
   <env> _ => Env </env>

rule [ReturnInTryFinally]:
    <k> (. => FinallyS) ~> 'Return('Some(V)) ...</k>
    <control>
      <stack> ListItem((finally,_,FinallyS,_,Env,C)) => . ...</stack>
      (_ => C)
    </control>
    <env> _ => Env </env>

rule [ReturnPassThrough]:
    <k> 'Return('Some(V)) ...</k>
    <stack> ListItem((LayerType,_,_,_,_,_:Bag)) => . ...</stack>
when
            LayerType =/=Bool return
    andBool LayerType =/=Bool finally

/*@ \section{Throw statement}
Exceptions are propagated now until a catch that can bind them is
encountered. */

context 'Throw(HOLE)

rule [Throw]:
    <k>
      'Throw(V) ~> _:K
      =>  'If(
            (subtype typeOf(V), T),,
            'Block('ListWrap('LocalVarDecStm('LocalVarDec(
                'ListWrap(.List{K}),, T,, 'ListWrap('VarDec(X,, V)))),,
                CatchS)),,
            'Throw(V)
          )
          ~> K
    </k>
    <control>
      <stack>
        ListItem((catch, 'Param(_:K,, T,, X:#Id) ,CatchS,K,Env,C)) => .
        ...
      </stack>
      (_ => C)
    </control>
    <env> _ => Env </env>

rule [ThrowInTryFinally]:
    <k> (. => FinallyS) ~> 'Throw(_:Val) ...</k>
    <control>
      <stack> ListItem((finally,_,FinallyS,_,Env,C)) => . ...</stack>
      (_ => C)
    </control>
    <env> _ => Env </env>

rule [ThrowPassThrough]:
    <k> 'Throw(_:Val) ...</k>
    <stack> ListItem((LayerType:#Id,_,_,_,_,_:Bag)) => . ...</stack>
when
            LayerType =/=Bool catch
    andBool LayerType =/=Bool finally

rule [ThrowCausesThreadTermination]:
    <k>
      'Throw(V) ~> _:K
      => 'ExprStm('Invoke(printMethodVal,,
          'ListWrap("Thread terminated with exception: ",,V,,"\n")))
    </k>
    <stack> .List </stack>

//@ \section{Try statement}

rule [TryCatchFinallyDesugar]:
    'Try(TryS:K,, 'ListWrap( K,,Ks),,FinallyS:K)
    => 'Try('Try(TryS,,'ListWrap( K,,Ks)),,'ListWrap(.List{K}),,FinallyS)
        [structural]

rule [TryCatchCatchDesugar]:
    'Try(TryS,, 'ListWrap(Ks,, K1:K,, K2:K))
    => 'Try('Try(TryS,, 'ListWrap( Ks,,K1)),, 'ListWrap(K2))
        [structural]

//@ \subsection{Execution of try–catch} JLS 14.20.1

//eval the type of catch argument
context 'Try(_:K,,'ListWrap('Catch('Param(_:K,, HOLE,, _),, _)))

rule [TryCatch]:
    <k>
      ( 'Try(TryS:K,, 'ListWrap('Catch(CatchParam:K,, CatchS:K)))
        => TryS ~> popx )
      ~> K
    </k>
    <control>
      <stack> . => ListItem((catch,CatchParam,CatchS,K,Env,C)) ...</stack>
      C:Bag
    </control>
    <env> Env </env>

//@ \subsection{Execution of try-finally} JLS 14.20.2

rule [TryFinally]:
    <k>
      ( 'Try(TryS:K ,,'ListWrap(.List{K}),,FinallyS:K)
        => TryS ~> popx ~> FinallyS )
      ~> K
    </k>
    <control>
      <stack> . => ListItem((finally,.K,FinallyS,.K,Env,C)) ...</stack>
      C:Bag
    </control>
    <env> Env </env>

//@ \section{Auxiliary operations}

rule [ThreadTermination]:
    ( <thread>
        ...
        <k>.K</k>
        <holds> H:Map </holds>
        ...
      </thread>
    => .)
    <busy> Busy:Set => Busy -Set keys(H) </busy>
    <dissolveEmptyK> true </dissolveEmptyK>

end module
